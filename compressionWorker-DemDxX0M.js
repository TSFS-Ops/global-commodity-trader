(function(){"use strict";function F(i){return["image/jpeg","image/jpg","image/png","image/webp","image/heic","image/heif"].includes(i.toLowerCase())}async function j(i){const s=i.getContext("2d");if(!s)return!0;const r=s.getImageData(0,0,Math.min(i.width,100),Math.min(i.height,100)),o=new Set;for(let e=0;e<r.data.length;e+=16){const t=r.data[e],n=r.data[e+1],g=r.data[e+2],a=r.data[e+3];if(o.add(`${t},${n},${g},${a}`),o.size>32)return!0}for(let e=3;e<r.data.length;e+=4)if(r.data[e]<255)return!1;return o.size>16}function B(i,s,r,o){let{width:e,height:t}={width:i,height:s};if(e<=r&&t<=o)return{width:e,height:t};const n=e/t;return e>t?(e=Math.min(e,r),t=e/n):(t=Math.min(t,o),e=t*n),{width:Math.round(e),height:Math.round(t)}}async function P(i){return new Promise((s,r)=>{const o=new FileReader;o.onload=()=>s(o.result),o.onerror=()=>r(new Error("Failed to read blob")),o.readAsArrayBuffer(i)})}async function R(i,s,r,o,e,t){const n=i.byteLength;try{if(!F(r)){t({type:"result",fileIndex:e,fileName:s,success:!0,compressedBuffer:i,compressedType:r,originalSize:n,compressedSize:n,compressionRatio:1});return}t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"reading",progress:10,message:"Reading image..."}});const g=new Blob([i],{type:r}),a=await createImageBitmap(g);t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"processing",progress:30,message:"Processing image..."}});let h=B(a.width,a.height,o.maxWidth,o.maxHeight);const p=new OffscreenCanvas(h.width,h.height),u=p.getContext("2d");if(!u)throw new Error("Canvas not supported");u.drawImage(a,0,0,h.width,h.height),a.close(),t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"compressing",progress:60,message:"Compressing..."}});let d=r;o.convertFormat&&(r==="image/heic"||r==="image/heif"||r==="image/png"&&await j(p))&&(d="image/jpeg");const l=o.maxSizeMB*1024*1024,z=[.78,.68,.58,.48,.38,.28],C=[{width:o.maxWidth,height:o.maxHeight},{width:1400,height:1400},{width:1200,height:1200},{width:1e3,height:1e3},{width:800,height:800},{width:600,height:600}];let c=null,y=0;const S=z.length*C.length;for(const $ of C){const m=B((a==null?void 0:a.width)||h.width,(a==null?void 0:a.height)||h.height,$.width,$.height);if(m.width!==h.width||m.height!==h.height){p.width=m.width,p.height=m.height;const f=new Blob([i],{type:r}),w=await createImageBitmap(f);u.drawImage(w,0,0,m.width,m.height),w.close()}for(const f of z){y++;const w=60+y/S*30;t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"compressing",progress:w,message:`Optimizing (${y}/${S})...`}});try{if(c=await p.convertToBlob({type:d,quality:d==="image/jpeg"?f:void 0}),c.size<=l)break}catch(v){console.warn("Compression attempt failed:",v);continue}}if(c&&c.size<=l)break}if(!c)throw new Error("Failed to create compressed blob");if(c.size>l){t({type:"error",fileIndex:e,fileName:s,error:`Unable to compress ${s} below ${o.maxSizeMB}MB limit. Current size: ${(c.size/1024/1024).toFixed(1)}MB. Try a smaller image.`});return}const b=await P(c);t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"complete",progress:100,message:"Complete!"}});const k=n/b.byteLength;t({type:"result",fileIndex:e,fileName:s,success:!0,compressedBuffer:b,compressedType:d,originalSize:n,compressedSize:b.byteLength,compressionRatio:k})}catch(g){t({type:"progress",fileIndex:e,fileName:s,progress:{stage:"error",progress:0,message:"Compression failed"}}),t({type:"error",fileIndex:e,fileName:s,error:g instanceof Error?g.message:"Unknown error"})}}self.onmessage=async i=>{const{type:s,fileBuffer:r,fileName:o,fileType:e,options:t,fileIndex:n}=i.data;s==="compress"&&await R(r,o,e,t,n,g=>self.postMessage(g))}})();
